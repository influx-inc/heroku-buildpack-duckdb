#!/usr/bin/env bash
# Installs the DuckDB C library (header + shared object) so the duckdb Ruby gem
# can compile its native extension during the Ruby buildpack's bundle install.
#
# Uses bin/export to set C_INCLUDE_PATH and LIBRARY_PATH so the compiler can
# find duckdb.h and libduckdb.so. This avoids BUNDLE_BUILD__DUCKDB, which is
# broken by bundler's backslash-escaping of = signs (rubygems/rubygems#3727).

set -euo pipefail

BUILD_DIR="$1"
CACHE_DIR="$2"

DUCKDB_VERSION="1.4.3"
DUCKDB_CACHE="$CACHE_DIR/duckdb-$DUCKDB_VERSION"
DUCKDB_URL="https://github.com/duckdb/duckdb/releases/download/v${DUCKDB_VERSION}/libduckdb-linux-amd64.zip"
DUCKDB_INSTALL="$BUILD_DIR/vendor/duckdb"

echo "-----> Installing DuckDB C library v${DUCKDB_VERSION}"

if [ -d "$DUCKDB_CACHE" ]; then
  echo "       Using cached DuckDB libraries"
else
  echo "       Downloading from GitHub..."
  mkdir -p "$DUCKDB_CACHE"
  curl -sL "$DUCKDB_URL" -o "$DUCKDB_CACHE/libduckdb.zip"
  unzip -qo "$DUCKDB_CACHE/libduckdb.zip" -d "$DUCKDB_CACHE"
  rm "$DUCKDB_CACHE/libduckdb.zip"
fi

mkdir -p "$DUCKDB_INSTALL/include" "$DUCKDB_INSTALL/lib"
cp "$DUCKDB_CACHE/duckdb.h" "$DUCKDB_INSTALL/include/"
cp "$DUCKDB_CACHE/libduckdb.so" "$DUCKDB_INSTALL/lib/"

# Runtime profile.d script â€” sets LD_LIBRARY_PATH when the dyno boots
mkdir -p "$BUILD_DIR/.profile.d"
cat > "$BUILD_DIR/.profile.d/duckdb.sh" <<'PROFILE'
export LD_LIBRARY_PATH="$HOME/vendor/duckdb/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
PROFILE

echo "-----> DuckDB C library installed"
